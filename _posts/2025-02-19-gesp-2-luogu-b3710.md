---
layout: post
title: 【GESP】C++二级真题 luogu-B3710 [语言月赛202302] 破碎的历史
date: 2025-02-19 08:00 +0800
author: OneCoder
comments: true
math: true
tags: [GESP, C++]
categories: [GESP, 二级]
---
GESP二级练习，多层循环和分支以及数学函数练习，难度★★☆☆☆。

<!--more-->

## luogu-B3710 [语言月赛202302] 破碎的历史

### 题目要求

#### 题目描述

>某 E 设计了一款抽卡模拟器，她希望能够抽到最好的卡片 CARD。
>
>这款抽卡模拟器将在第 $5$ 次抽取保底。也就是说，如果前 $4$ 次抽取都没有抽中卡片 CARD，第 $5$ 次一定能够抽中卡片 CARD。
>
>某 E 希望你设定第 $1$ 次至第 $4$ 次抽取抽中的概率 $p_1,p_2,p_3,p_4$，使得最后保底的概率为 $S$。
>
>$p_1,p_2,p_3,p_4$ 应当在 $[0,1]$ 范围内，且精确到小数点后两位，如 $0.12$。
>
>容易发现，$S = (1-p_1)\cdot(1-p_2)\cdot(1-p_3)\cdot(1-p_4)$。
>
>某 E 想要知道一共有多少设置的方案。

#### 输入格式

>输入一行一个浮点数 $S$，$S$ 精确到小数点后 $8$ 位。

#### 输出格式

>输出一行一个整数，代表方案数。

#### 输入 #1

```console
0.00353280
```

#### 输出 #1

```console
2520
```

#### 说明/提示

对于 $10\%$ 的测试数据，$S = 1.0$；  
对于 $100\%$ 的测试数据，$0.0 \le S \le 1.0$。

---

### 题目分析

#### 解题思路

1. 首先，我们需要理解题目的核心要求：
   - 需要设定4个概率值p1,p2,p3,p4，每个值在[0,1]范围内且精确到小数点后2位
   - 这4个概率值要满足(1-p1)(1-p2)(1-p3)(1-p4) = S
   - S是一个精确到小数点后8位的浮点数

2. 解题思路：
   - 由于概率值精确到小数点后2位，我们可以将问题转化为整数问题
   - 将每个概率值乘以100，变成0-100的整数
   - 将S乘以100000000，转换为对应的整数值
   - 问题转化为找到满足条件的i,j,k,l组合数量，其中(100-i)(100-j)(100-k)(100-l)=target

3. 具体实现：
   - 使用四重循环遍历所有可能的概率值组合(0-100)
   - 对每个组合计算乘积是否等于目标值
   - 统计满足条件的组合数量

{% include custom/custom-post-content-inner.html %}

---·

### 示例代码

```cpp
#include<iostream>
using namespace std;
int main() {
    // 定义浮点数S用于存储输入
    double S;
    cin >> S;
    // 将小数转换为整数便于计算
    int target = S * 100000000;
    // 用于统计满足条件的方案数
    int count = 0;
    // 四重循环遍历所有可能的组合
    for (int i = 0; i <= 100; i++) {
        for (int j = 0; j <= 100; j++) {
            for (int k = 0; k <= 100; k++) {
                for (int l = 0; l <= 100;l++) {
                    // 判断当前组合是否满足条件
                    if ((100 - i) * (100 - j) * (100 -k) * (100 - l)== target) {
                        count++;
                    }
                }
            }
        }
    }
    // 输出结果
    cout << count;
    return 0;
}
```

---

{% include custom/custom-post-content-footer.md %}
