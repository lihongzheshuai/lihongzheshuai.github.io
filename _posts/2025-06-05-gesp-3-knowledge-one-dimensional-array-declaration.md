---
layout: post
title: 【GESP】C++三级知识点研究，一维数组声明合法性
date: 2025-06-05 08:00 +0800
author: OneCoder
comments: true
math: true
mermaid: true
tags: [GESP, C++]
categories: [GESP, 三级, 考点]
---
一维数组是GESP C++三级考试大纲中的要求，
> （5）C++一维数组基本应用；Python 列表、字典、元组、集合的基本应用、内置
函数以及列表解析的使用.
{: .prompt-info}

在以往的GESP考试真题中，除在编程题中经常使用到一维数组外，在前面的客观题中还会经常出现关于一维数组声明合法性的题目。因此，本文针对该知识点进行详细的整理。

---

在 C++ 中，一维数组是由**若干个相同类型元素组成的连续内存空间**。C++ 的数组语法来源于 C，但提供了更多现代化的封装和替代方案。下面我们将从 **语法定义** 开始，详细介绍 C++ 中一维数组的 **所有合法声明方式**，并给出示例。

## 🧩 一、一维数组的语法定义

### 基本语法

```cpp
type arrayName[arraySize];
```

* `type`: 元素的数据类型，如 `int`、`double`、`char` 等；
* `arrayName`: 数组名（标识符）；
* `arraySize`: 数组长度，必须是**正整数常量表达式**（在静态数组中）。

### 示例

```cpp
int nums[5];       // 声明长度为5的整型数组
double scores[10]; // 长度为10的浮点型数组
```

---

## 🧭 二、C++ 中一维数组合法的声明方式汇总

### ✅ 1. **静态一维数组（编译时固定大小）**

数组大小在编译时已知，分配在栈区。

#### ✅ 示例 1.1：未初始化数组

```cpp
int arr[5]; // 每个元素值未定义
```

#### ✅ 示例 1.2：完全初始化

```cpp
int arr[5] = {1, 2, 3, 4, 5};
```

#### ✅ 示例 1.3：部分初始化（其余为 0）

```cpp
int arr[5] = {1, 2}; // 等价于 {1, 2, 0, 0, 0}
```

#### ✅ 示例 1.4：自动推导长度

```cpp
int arr[] = {10, 20, 30}; // 推导长度为3
```

---

### ✅ 2. **动态数组（运行时分配内存，使用 `new`）**

适用于程序运行过程中，数组长度需要根据用户输入或其他条件动态确定的场景。例如：

* 用户输入一个数字 n，需要创建长度为 n 的数组
* 从文件读取数据，事先不知道数据量大小
* 根据某些计算结果决定所需数组大小

这里需要特别说明一点，虽然在某些编译器中可能允许使用变量作为静态数组的长度(如 `int arr[n]`)，但这实际上是编译器的扩展特性，并不是 C++ 标准所允许的。标准 C++ 要求静态数组的大小必须是编译期常量。使用动态数组的主要原因是：

1. 标准兼容性：使用 `new` 创建的动态数组完全符合 C++ 标准
2. 内存管理灵活：可以在需要时分配，不需要时释放
3. 大小限制：栈空间较小，大数组应该放在堆上

```cpp
int size = 5;
int* arr = new int[size]; // 分配长度为5的数组

arr[0] = 42; // 访问元素

delete[] arr; // 释放内存
```

* 分配在堆区，需手动 `delete[]`
* 没有自动初始化（可能是垃圾值）

---

### ✅ 3. **使用 `std::array`（C++11）**

现代 C++ 推荐的固定长度数组类型，提供容器接口。

```cpp
#include <array>

std::array<int, 3> arr = {1, 2, 3};

arr[1] = 42; // 访问第二个元素
```

* 优点：类型安全、有成员函数（如 `.at()`, `.size()`）
* 缺点：长度在编译期固定

---

### ✅ 4. **使用 `std::vector`（动态长度数组）**

`std::vector` 是动态数组的首选方式。

```cpp
#include <vector>

std::vector<int> arr = {1, 2, 3};
arr.push_back(4); // 添加元素

std::cout << arr[3]; // 输出4
```

* 自动管理内存
* 可变长度
* 可使用范围 `for` 循环和 STL 算法

---

### ✅ 5. **用指针指向数组首地址（间接方式）**

合法但需小心内存管理。

```cpp
int data[3] = {1, 2, 3};
int* ptr = data;

std::cout << ptr[1]; // 输出2
```

* 本质上 `ptr` 是一个指向数组首地址的指针
* 语法上 `ptr[i]` == `*(ptr + i)`

---

### ✅ 6. **函数参数中的数组声明（退化为指针）**

数组作为参数时会退化为指针。

```cpp
void printArray(int arr[], int size) {
    for(int i = 0; i < size; ++i)
        std::cout << arr[i] << " ";
}
```

也可以写作：

```cpp
void printArray(int* arr, int size);
```

---

## 📌 三、总结对比表

| 声明方式                     | 长度确定时机 | 内存位置 | 自动释放 | 可变长度 | 推荐程度   |
| ------------------------ | ------ | ---- | ---- | ---- | ------ |
| `int arr[5];`            | 编译期    | 栈    | 是    | 否    | ✅✅     |
| `int* arr = new int[n];` | 运行期    | 堆    | 否    | 否    | ⚠️ 需谨慎 |
| `std::array<int, 5>`     | 编译期    | 栈    | 是    | 否    | ✅✅✅    |
| `std::vector<int>`       | 运行期    | 堆    | 是    | 是    | ✅✅✅✅   |
| `int* ptr = arr;`        | 编译期    | 栈    | 是    | 否    | ⚠️ 限制多 |

---

---
{% include custom/custom-post-content-footer.md %}
