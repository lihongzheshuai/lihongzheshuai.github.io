---
layout: post
title: 【GESP】C++三级真题 luogu-B4413 [GESP202509 三级] 数组清零
date: 2025-09-30 08:00 +0800
author: OneCoder
comments: true
math: true
tags: [GESP, C++, 多重循环, 一维数组]
categories: [GESP, 三级]
---
GESP C++ 2025年9月三级真题，一维数组考点，难度★★☆☆☆。

<!--more-->

## luogu-B4413 [GESP202509 三级] 数组清零

### 题目要求

#### 题目描述

>小 A 有一个由 $n$ 个非负整数构成的数组 $a = [a_1, a_2, \ldots, a_n]$。他会对阵组 $a$ 重复进行以下操作，直到数组 $a$ 只包含 0。在一次操作中，小 A 会依次完成以下三个步骤：
>
>1. 在数组 $a$ 中找到最大的整数，记其下标为 $k$。如果有多个最大值，那么选择其中下标最大的。
>2. 从数组 $a$ 所有不为零的整数中找到最小的整数 $a_j$。
>3. 将第一步找出的 $a_k$ 减去 $a_j$。
>
>例如，数组 $a = [2, 3, 4]$ 需要 7 次操作变成 $[0, 0, 0]$：
>
>$$
>[2, 3, 4] \rightarrow [2, 3, 2] \rightarrow [2, 1, 2] \rightarrow [2, 1, 1] \rightarrow [1, 1, 1] \rightarrow [1, 1, 0] \rightarrow [1, 0, 0] \rightarrow [0, 0, 0]
>$$
>
>小 A 想知道，对于给定的数组 $a$，需要多少次操作才能使得 $a$ 中的整数全部变成 0。可以证明，$a$ 中整数必然可以在有限次操作后全部变成 0。你能帮他计算出答案吗？

#### 输入格式

>第一行，一个正整数 $n$，表示数组 $a$ 的长度。
>
>第二行，$n$ 个非负整数 $a_1, a_2, \ldots, a_n$，表示数组 $a$ 中的整数。

#### 输出格式

>一行，一个正整数，表示 $a$ 中整数全部变成 0 所需要的操作次数。

#### 输入输出样例 #1

##### 输入 #1

```plaintext
3
2 3 4
```

##### 输出 #1

```plaintext
7
```

#### 输入输出样例 #2

##### 输入 #2

```plaintext
5
1 3 2 2 5
```

##### 输出 #2

```plaintext
13
```

#### 说明/提示

对于所有测试点，保证 $1 \leq n \leq 100$，$0 \leq a_i \leq 100$。

---

### 题目分析

1. **模拟过程**  

按题意循环三步：

- 找最大非零下标（最右优先）；  
- 在非零元素里找最小值；  
- 把最大值减去该最小值，计数+1。  
- 当数组全零时结束。

2. **复杂度分析**  
   每轮扫描需要 $O(n)$ 时间，最坏情况下总操作次数不超过 $\sum a_i \le 10^4$（每次至少把当前最大值减1，总共需要元素和次），$n\le 100$，整体复杂度 $O(n\cdot\sum a_i)\approx 10^6$，在题目约束下完全可行。

{% include custom/custom-post-content-inner.html %}

---

### 示例代码

```cpp
#include <iostream>

int num_ary[105]; // 存放数组，最多100个元素
int main() {
    int n;
    std::cin >> n; // 读入数组长度
    int count = 0; // 记录操作次数
    for (int i = 0; i < n; i++) {
        std::cin >> num_ary[i]; // 读入数组元素
    }
    bool flag = false; // 标记数组是否全为0
    while (true) {
        flag = true; // 假设已全部清零
        int min = 101; // 初始化最小值（大于题设上限100）
        int max = 0;   // 初始化最大值
        int max_idx = -1; // 最大值下标
        for (int i = 0; i < n; i++) {
            if (num_ary[i] != 0) {
                flag = false; // 发现非零，未清零
            } else {
                continue; // 零元素跳过
            }
            // 更新非零最小值
            if (num_ary[i] < min && num_ary[i] != 0) {
                min = num_ary[i];
            }
            // 更新最大值及其下标（取最右）
            if (num_ary[i] >= max) {
                max = num_ary[i];
                max_idx = i;
            }
        }
        if (flag) {
            break; // 全部清零，退出循环
        }
        // 将最大元素减去最小元素
        num_ary[max_idx] -= min;
        count++; // 操作次数+1
    }

    std::cout << count << std::endl; // 输出总操作次数
    return 0;
}
```

---

{% include custom/custom-post-content-footer.md %}
