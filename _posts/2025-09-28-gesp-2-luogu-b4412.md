---
layout: post
title: 【GESP】C++二级真题 luogu-B4412 [GESP202509 二级] 菱形
date: 2025-09-28 18:00 +0800
author: OneCoder
comments: true
math: true
tags: [GESP, C++, 多层循环]
categories: [GESP, 二级]
---
GESP二级真题，多层循环练习，难度★✮☆☆☆。

<!--more-->

## luogu-B4412 [GESP202509 二级] 菱形

### 题目要求

#### 题目描述

>小 A 想绘制一个菱形。具体来说，需要绘制的菱形是一个 $n$ 行 $n$ 列的字符画，$n$ 是一个大于 $1$ 的奇数。菱形的四个顶点依次位于第 $1$ 行、第 $1$ 列、第 $n$ 行、第 $n$ 列的正中间，使用 `#` 绘制。相邻顶点之间也用 `#` 连接。其余位置都是 `.`。
>
>例如，一个 $5$ 行 $5$ 列的菱形字符画是这样的：
>
>```plaintext
>..#..
>.#.#.
>#...#
>.#.#.
>..#..
>```
>
>给定 $n$，请你帮小 A 绘制对应的菱形。

#### 输入格式

>一行，一个正整数 $n$。

#### 输出格式

>输出共 $n$ 行，表示对应的菱形。

#### 输入输出样例 #1

##### 输入 #1

```plaintext
3
```

##### 输出 #1

```plaintext
.#.
#.#
.#.
```

#### 输入输出样例 #2

##### 输入 #2

```plaintext
9
```

##### 输出 #2

```plaintext
....#....
...#.#...
..#...#..
.#.....#.
#.......#
.#.....#.
..#...#..
...#.#...
....#....
```

#### 说明/提示

对于所有测试点，保证 $3 \leq n \leq 29$ 并且 $n$ 为奇数。

---

### 题目分析

本题要求输出一个 $n \times n$ 的“菱形”图案，$n$ 为奇数。每行每列只包含字符 `#` 和 `.`，`#` 组成菱形的边界，其余为 `.`。

#### 核心思路

1. **确定中心位置**  
   由于 $n$ 为奇数，中心行为 $\text{mid} = \frac{n+1}{2}$，中心列同理。

2. **分行讨论**  
   - **首行和末行**：只有中心列为 `#`，其余为 `.`。
   - **上半部分（第 $1$ 行到第 $\text{mid}-1$ 行）**：每行有两个 `#`，分别在:
  
    $$
    \begin{cases}
    \text{左斜线列号} = \text{mid} - i + 1 \\
    \text{右斜线列号} = \text{mid} + i - 1
    \end{cases}
    $$

   - **中间行（第 $\text{mid}$ 行）**：只有首列和末列为 `#`。
   - **下半部分（第 $\text{mid}+1$ 行到第 $n$ 行）**：与上半部分对称，`#` 分别在:
    $$
    \begin{cases}
    \text{左斜线列号} = i - \text{mid} + 1 \\
    \text{右斜线列号} = n - i + \text{mid}
    \end{cases}
    $$

3. **遍历输出**  
   双重循环枚举每个位置，判断是否为 `#`，否则输出 `.`。

#### 复杂度分析

- 时间复杂度 $O(n^2)$，空间复杂度 $O(1)$，$n \leq 29$ 时完全可行。

#### 细节注意

- 行列编号从 $1$ 开始更便于公式表达。
- 输出时每行末尾不要多余空格。

本题考查二维模拟与对称性分析，理解行列与中心的关系是关键。

{% include custom/custom-post-content-inner.html %}

---

### 示例代码

```cpp
#include <iostream>

int main() {
    int n;
    std::cin >> n;                    // 读入菱形边长（奇数）
    int mid = (n + 1) / 2;              // 计算中心行/列位置
    for (int i = 1; i <= n; i++) {    // 逐行绘制
        for (int j = 1; j <= n; j++) { // 逐列绘制
            if (i == 1 || i == n) {    // 首行或末行：仅中心位置输出 #
                if (j == mid) {
                    std::cout << "#";
                } else {
                    std::cout << ".";
                }
            } else if (i < mid) {      // 上半部分：对称的两条斜线
                // 上半部分：左斜线列号 = 中心列 - 当前行 + 1，右斜线列号 = 中心列 + 当前行 - 1
                if (j == mid - i + 1 || j == mid + i - 1) {
                    std::cout << "#";
                } else {
                    std::cout << ".";
                }
            } else {                   // 下半部分：对称的两条斜线
                // 左斜线列号 = 当前行 - 中心行 + 1，右斜线列号 = 总列数 - 当前行 + 中心行
                if (j == i - mid + 1 || j == n - i + mid) {
                    std::cout << "#";
                } else {
                    std::cout << ".";
                }
            }
        }
        std::cout << "\n";             // 换行进入下一行
    }
    return 0;
}
```

---

{% include custom/custom-post-content-footer.md %}
