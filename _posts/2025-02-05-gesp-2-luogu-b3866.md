---
layout: post
title: 【GESP】C++二级真题 luogu-b3866, [GESP202309 二级] 数字黑洞
date: 2025-02-05 12:30 +0800
author: OneCoder
comments: true
math: true
tags: [GESP, C++]
categories: [GESP, 二级]
---
GESP二级真题，多层循环、分支语句、数学函数练习，难度★✮☆☆☆。

<!--more-->

## luogu-B3865 [GESP202309 二级] 数字黑洞

### 题目要求

#### 题目描述

>给定一个三位数，要求各位不能相同。例如，$352$ 是符合要求的，$112$ 是不符合要求的。将这个三位数的三个数字重新排列，得到的最大的数，减去得到的最小的数，形成一个新的三位数。对这个新的三位数可以重复上述过程。神奇的是，最终一定会得到 $495$！
>
>试试看，重新排列 $352$，得到的最大数为 $532$，最小数为 $235$，它们的差是 $297$；变换 $297$，得到 $972-279=693$；变换 $693$，$963-369=594$；变换 $594$，$954-459=495$。因此，经过 $4$ 次变换得到了 $495$。
>
>现在，输入的三位数，你能通过编程得出，这个三位数经过多少次变换能够得到 $495$ 吗？

#### 输入格式

>输入一行，包含一个符合要求的三位数 $N$。

#### 输出格式

>输出一行，包含一个整数 $C$，表示经过 $C$ 次变换得到 $495$。

#### 样例输入 #1

```console
352
```

#### 样例输出 #1

```console
4
```

---

### 题目分析

#### 解题思路

1. 首先，读取输入的三位数 `N`。
2. 初始化一个计数变量 `count`，用于记录变换的次数。
3. 使用一个循环来执行变换过程，直到 `N` 等于 `495`。
4. 在每次循环中，首先找到 `N` 的最大数、最小数和中间数。
5. 计算最大数和最小数的差，得到一个新的三位数 `N`。
6. 每次循环结束后，计数 `count` 增加 1。
7. 当 `N` 等于 `495` 时，跳出循环并输出计数 `count`。

{% include custom/custom-post-content-inner.html %}

---

### 示例代码

```cpp
#include <cmath>
#include <iostream>

using namespace std;
int main() {
    int n; // 定义变量n
    cin >> n; // 读取输入的n
    int count = 0; // 初始化计数为0
    while (true) {
        if (n == 495) { // 如果n等于495，则跳出循环
            cout << count; // 输出计数
            break;
        }
        int n1 = n % 10; // 获取n的个位数
        int n2 = n / 10 % 10; // 获取n的十位数
        int n3 = n / 10 / 10; // 获取n的百位数

        int n_max = max(n1, max(n2, n3)); // 找到最大数
        int n_min = min(n1, min(n2, n3)); // 找到最小数
        int n_mid = n1 + n2 + n3 - n_max - n_min; // 计算中间数

        n = n_max * 100 + n_mid * 10 + n_min - n_min * 100 - n_mid * 10 - n_max; // 更新n的值
        count++; // 计数增加
    }

    return 0;
}
```

---

{% include custom/custom-post-content-footer.md %}
