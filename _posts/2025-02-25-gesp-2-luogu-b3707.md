---
layout: post
title: 【GESP】C++二级练习 luogu-B3707 [语言月赛202302] 风神瞳
date: 2025-02-25 08:00 +0800
author: OneCoder
comments: true
math: true
tags: [GESP, C++]
categories: [GESP, 二级]
---
GESP二级练习，多层循环和分支练习，难度★★☆☆☆。

<!--more-->

## luogu-B3707 [语言月赛202302] 风神瞳

### 题目要求

#### 题目描述

>你正在帮助他们设计一款象棋软件。现在，你想要设计一个逻辑功能。以下是对这个功能的介绍。
>
>想象一个无限大的棋盘，我们用 $(x, y)$ 表示棋盘的第 $x$ 行第 $y$ 列。具体的，如果说一个棋子在 $(x, y)$ 位置，那么这个棋子则在棋盘的第 $x$ 行第 $y$ 列。
>
>现在有四种棋子**车、炮、马、象**。它们对应的**编号**及它们的**吃棋子规则**如下表所示。以下规则均假设当前棋子在 $(x, y)$ 位置。
>
>**请注意，以下规则可能与真实的中国象棋规则略有不同。**
>
>| 名称 | 编号 | 走法规则 |
>| :----------: | :----------: | :----------: |
>| 车 | $1$ | 可沿横线或者竖线移动，即一次操作可以吃掉 $(x + k, y), (x - k, y), (x, y + k), (x, y - k)$ 中的任意一个位置的棋子（$k$ 为任意正整数）。 |
>| 炮 | $2$ | 想象一条直线，炮与对方棋子都在这条直线上。那么只有在这条直线上的炮与对方棋子的中间**有一个另外的棋子**时，炮才能吃掉对方。 |
>| 马 | $3$ | 马走日，即一次操作可以吃掉 $(x + 2, y + 1), (x + 2, y - 1), (x - 2, y + 1), (x - 2, y - 1), (x + 1, y + 2), (x + 1, y - 2), (x - 1, y + 2), (x - 1, y - 2)$ 中的任意一个位置的棋子。 |
>| 象 | $4$ | 象走田，即一次操作可以吃掉 $(x + 2, y + 2), (x + 2, y - 2), (x - 2, y + 2), (x - 2, y - 2)$ 中的任何一个位置的棋子。 |
>
>现在你得到了一组询问，包含 $p, x _ 0, y _ 0, x _ 1, y _ 1$ 五个整数，代表现在棋盘上**只有**两个棋子，第一个棋子编号为 $p$，在第 $x _ 0$ 行，第 $y _ 0$ 列。第二个棋子编号未知且不需要了解，在第 $x _ 1$ 行，第 $y _ 1$ 列。
>
>你需要考虑，如果你现在可以且仅可以操作第一个棋子**一次**，第一个棋子能否吃掉第二个棋子。

#### 输入格式

>输入共一行。
>
>第一行为五个整数 $p, x _ 0, y _ 0, x _ 1, y _ 1$，两两之间以一个空格隔开，同题面中的含义。

#### 输出格式

>输出一行，如果第一个棋子可以吃掉第二个棋子，输出 `Yes`，否则输出 `No`。

#### 输入 #1

```console
1 1 4 2 4
```

#### 输出 #1

```console
Yes
```

#### 输入 #2

```console
1 1 4 2 5
```

#### 输出 #2

```console
No
```

#### 输入 #3

```console
2 1 1 2 1
```

#### 输出 #3

```console
No
```

#### 输入 #4

```console
3 1 4 2 6
```

#### 输出 #4

```console
Yes
```

### 说明/提示

#### 样例解释

样例组 #1 与 #2 代表了车能够与不能够吃掉对方棋子的情况。

样例组 #3 代表了炮不能够吃掉对方棋子的情况。

样例组 #4 代表了马能够吃掉对方棋子的情况。

<https://www.luogu.com.cn/paste/et767k4o> 中含有所有样例的棋子摆放情况，可以按需查阅。

#### 数据规模与约定

对于 $20\%$ 的数据，保证 $p = 2$；  
对于 $100\%$ 的数据，保证 $p \in \{1, 2, 3, 4\}$，$1 \leq x _ 0, y _ 0, x _ 1, y _ 1 \leq 10 ^ 9$，且保证不存在 $x _ 0$ 与 $x _ 1$、$y _ 0$ 与 $y _ 1$ 同时相等的情况，即两个棋子不会重合。

---

### 题目分析

#### 解题思路

1. 首先，我们需要理解题目的核心要求：
   - 计算 $a^b$ 的末3位数字
   - 不足3位需要在前面补0

2. 解题思路：
   - 直接计算 $a^b$ 会导致数字过大，超出整型范围
   - 我们只需要关注末3位数字，可以在每次计算时只保留末3位
   - 具体做法是每次乘法后对1000取模

3. 具体实现：
   - 读入底数a和指数b
   - 用一个变量ans记录当前结果,初始值为a
   - 循环b-1次:
     - 每次将ans乘以a
     - 取乘积的末3位(对1000取模)存回ans
   - 最后输出ans的3位数字，不足补0

{% include custom/custom-post-content-inner.html %}

---

### 示例代码

```cpp
#include <iostream>
using namespace std;
int main() {
    int p, x, y, g, h;
    cin >> p >> x >> y >> g >> h;
    if (p == 1) {
        if (x == g || y == h) {
            cout << "Yes";
        } else {
            cout << "No";
        }
    } else if (p == 2) {
        cout << "No";
    } else if (p == 3) {
        if ((g == x + 2 && h == y + 1) || (g == x + 2 && h == y - 2) ||
            (g == x - 2 && h == y + 1) || (g == x - 2 && h == y - 1) ||
            (g == x + 1 && h == y + 2) || (g == x + 1 && h == y - 2) ||
            (g == x - 1 && h == y + 2) || (g == x - 1 && h == y - 2)) {
            cout << "Yes";
        } else {
            cout << "No";
        }
    } else {
        if ((g == x + 2 && h == y + 2) || (g == x + 2 && h == y - 2) ||
            (g == x - 2 && h == y + 2) || (g == x - 2 && h == y - 2)) {
            cout << "Yes";
        } else {
            cout << "No";
        }
    }
    return 0;
}
```

---

{% include custom/custom-post-content-footer.md %}
