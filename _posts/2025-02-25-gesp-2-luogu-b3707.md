---
layout: post
title: 【GESP】C++二级练习 luogu-B3707 [语言月赛202302] 风神瞳
date: 2025-02-25 08:00 +0800
author: OneCoder
comments: true
math: true
tags: [GESP, C++, 多重循环]
categories: [GESP, 二级]
---
GESP二级练习，多层循环和分支练习，难度★★☆☆☆。

<!--more-->

## luogu-B3707 [语言月赛202302] 风神瞳

### 题目要求

#### 题目描述

>你正在帮助他们设计一款象棋软件。现在，你想要设计一个逻辑功能。以下是对这个功能的介绍。
>
>想象一个无限大的棋盘，我们用 $(x, y)$ 表示棋盘的第 $x$ 行第 $y$ 列。具体的，如果说一个棋子在 $(x, y)$ 位置，那么这个棋子则在棋盘的第 $x$ 行第 $y$ 列。
>
>现在有四种棋子**车、炮、马、象**。它们对应的**编号**及它们的**吃棋子规则**如下表所示。以下规则均假设当前棋子在 $(x, y)$ 位置。
>
>**请注意，以下规则可能与真实的中国象棋规则略有不同。**
>
>| 名称 | 编号 | 走法规则 |
>| :----------: | :----------: | :----------: |
>| 车 | $1$ | 可沿横线或者竖线移动，即一次操作可以吃掉 $(x + k, y), (x - k, y), (x, y + k), (x, y - k)$ 中的任意一个位置的棋子（$k$ 为任意正整数）。 |
>| 炮 | $2$ | 想象一条直线，炮与对方棋子都在这条直线上。那么只有在这条直线上的炮与对方棋子的中间**有一个另外的棋子**时，炮才能吃掉对方。 |
>| 马 | $3$ | 马走日，即一次操作可以吃掉 $(x + 2, y + 1), (x + 2, y - 1), (x - 2, y + 1), (x - 2, y - 1), (x + 1, y + 2), (x + 1, y - 2), (x - 1, y + 2), (x - 1, y - 2)$ 中的任意一个位置的棋子。 |
>| 象 | $4$ | 象走田，即一次操作可以吃掉 $(x + 2, y + 2), (x + 2, y - 2), (x - 2, y + 2), (x - 2, y - 2)$ 中的任何一个位置的棋子。 |
>
>现在你得到了一组询问，包含 $p, x _ 0, y _ 0, x _ 1, y _ 1$ 五个整数，代表现在棋盘上**只有**两个棋子，第一个棋子编号为 $p$，在第 $x _ 0$ 行，第 $y _ 0$ 列。第二个棋子编号未知且不需要了解，在第 $x _ 1$ 行，第 $y _ 1$ 列。
>
>你需要考虑，如果你现在可以且仅可以操作第一个棋子**一次**，第一个棋子能否吃掉第二个棋子。

#### 输入格式

>输入共一行。
>
>第一行为五个整数 $p, x _ 0, y _ 0, x _ 1, y _ 1$，两两之间以一个空格隔开，同题面中的含义。

#### 输出格式

>输出一行，如果第一个棋子可以吃掉第二个棋子，输出 `Yes`，否则输出 `No`。

#### 输入 #1

```console
1 1 4 2 4
```

#### 输出 #1

```console
Yes
```

#### 输入 #2

```console
1 1 4 2 5
```

#### 输出 #2

```console
No
```

#### 输入 #3

```console
2 1 1 2 1
```

#### 输出 #3

```console
No
```

#### 输入 #4

```console
3 1 4 2 6
```

#### 输出 #4

```console
Yes
```

### 说明/提示

#### 样例解释

样例组 #1 与 #2 代表了车能够与不能够吃掉对方棋子的情况。

样例组 #3 代表了炮不能够吃掉对方棋子的情况。

样例组 #4 代表了马能够吃掉对方棋子的情况。

<https://www.luogu.com.cn/paste/et767k4o> 中含有所有样例的棋子摆放情况，可以按需查阅。

#### 数据规模与约定

对于 $20\%$ 的数据，保证 $p = 2$；  
对于 $100\%$ 的数据，保证 $p \in \{1, 2, 3, 4\}$，$1 \leq x _ 0, y _ 0, x _ 1, y _ 1 \leq 10 ^ 9$，且保证不存在 $x _ 0$ 与 $x _ 1$、$y _ 0$ 与 $y _ 1$ 同时相等的情况，即两个棋子不会重合。

---

### 题目分析

#### 解题思路

1. 首先，我们需要理解题目的核心要求：
   - 判断不同类型的棋子是否能够吃掉对方棋子

2. 解题思路：
   - 根据棋子类型，确定其移动规则
   - 车：可以在同一行或同一列移动
   - 炮：在此题中设定为不能吃掉对方棋子
   - 马：可以移动到“日”字形的8个位置
   - 象：可以移动到对角线的4个位置

3. 具体实现：
   - 读入棋子类型p和坐标(x, y)及目标坐标(g, h)
   - 根据p的值，判断棋子类型
   - 对于车，检查是否在同一行或同一列
   - 对于炮，直接输出不能吃掉
   - 对于马，检查是否在“日”字形的8个位置
   - 对于象，检查是否在对角线的4个位置
   - 输出结果为“是”或“否”表示能否吃掉对方棋子

{% include custom/custom-post-content-inner.html %}

---

### 示例代码

```cpp
#include <iostream>
using namespace std;
int main() {
    int p, x, y, g, h;  // 定义变量：棋子类型p，当前坐标(x,y)，目标坐标(g,h)
    cin >> p >> x >> y >> g >> h;  // 输入棋子类型和坐标
    
    if (p == 1) {  // 处理车的情况
        if (x == g || y == h) {  // 判断是否在同一行或同一列
            cout << "Yes";  // 可以吃掉
        } else {
            cout << "No";  // 不能吃掉
        }
    } else if (p == 2) {  // 处理炮的情况
        cout << "No";  // 直接输出不能吃掉
    } else if (p == 3) {  // 处理马的情况
        // 判断是否在马的8个可能位置
        if ((g == x + 2 && h == y + 1) || (g == x + 2 && h == y - 2) ||
            (g == x - 2 && h == y + 1) || (g == x - 2 && h == y - 1) ||
            (g == x + 1 && h == y + 2) || (g == x + 1 && h == y - 2) ||
            (g == x - 1 && h == y + 2) || (g == x - 1 && h == y - 2)) {
            cout << "Yes";  // 可以吃掉
        } else {
            cout << "No";  // 不能吃掉
        }
    } else {  // 处理象的情况
        // 判断是否在象的4个可能位置
        if ((g == x + 2 && h == y + 2) || (g == x + 2 && h == y - 2) ||
            (g == x - 2 && h == y + 2) || (g == x - 2 && h == y - 2)) {
            cout << "Yes";  // 可以吃掉
        } else {
            cout << "No";  // 不能吃掉
        }
    }
    return 0;  // 程序正常结束
}
```

---

{% include custom/custom-post-content-footer.md %}
