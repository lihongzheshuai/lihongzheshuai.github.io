---
layout: post
title: 【GESP】C++二级模拟 luogu-b3995, [GESP 二级模拟] 小洛的田字矩阵
date: 2025-02-06 13:00 +0800
author: OneCoder
comments: true
math: true
tags: [GESP, C++]
categories: [GESP, 二级]
---
GESP二级模拟题，多层循环、分支语句练习，难度★✮☆☆☆。

<!--more-->

## luogu-B3995  [GESP 二级模拟] 小洛的田字矩阵

### 题目要求

#### 题目描述

>小洛想要构造一个 $N\times N$  的田字矩阵（$N$ 为奇数）。具体来说：
>
>- 这个矩阵共有 $N$ 行，每行 $N$ 个字符，其中最左列、最右列都是 `|`；
>- 第一行、最后一行的第 $2\sim N-1$ 个字符都是 `-`；
>- 中间一行（即第 $\frac{N+1}{2}$ 行）的第 $2\sim \frac{N-1}{2}$，$\frac>{N+3}{2}\sim N-1$ 个字符都是 `-`；
>- 中间一列（即第 $\frac{N+1}{2}$ 列）的第 $2\sim \frac{N-1}{2}$，$\frac{N+3}{2}\sim N-1$ 个字符都是 `|`。
>- 其余所有字符都是半角小写字母 `x` 。
>
>例如，一个 $N = 5$ 田字矩阵如下:
>
>```console
>|---|
>|x|x|
>|-x-|
>|x|x|
>|---|
>```
>
>请你帮小洛根据给定的 $N$ 打印出对应的“田字矩阵”。

#### 输入格式

>一行一个整数 $N$（$5\leq N \leq 49$，保证 $N$ 为奇数）。

#### 输出格式

>输出对应的“田字矩阵”。
>
>请严格按格式要求输出，不要擅自添加任何空格、标点、空格等任何符号。你应该恰好输出 $N$ 行，每行除了换行符外恰好包含 $N$ 个字符，这些字符要么是 `-`，要么是 `|`，要么是 `x`。**你的输出必须和标准答案完全一致才能得分，请在提交前仔细检查**。

#### 样例输入 #1

```console
5
```

#### 样例输出 #1

```console
|---|
|x|x|
|-x-|
|x|x|
|---|
```

#### 样例输入 #2

```console
7
```

#### 样例输出 #2

```console
|-----|
|xx|xx|
|xx|xx|
|--x--|
|xx|xx|
|xx|xx|
|-----|
```

---

### 题目分析

#### 解题思路

1. 首先，读取输入的整数 `N`，并确保它在指定的范围内（$5\le N \le 49$）且为奇数。
2. 初始化一个循环变量 `i`，用于控制输出的行数。
3. 使用一个循环来输出“日字矩阵”，从 `1` 到 `N`。
4. 在每次循环中，首先输出一个竖线 `|`，然后根据行数 `i` 的位置输出相应的字符：
   - 如果 `i` 等于 `(N + 1) / 2`，输出 `-`，形成矩阵的中间横线。
   - 否则，输出 `x`，形成矩阵的上下边界和内部。
5. 每行输出完成后，输出一个竖线 `|`，并换行。
6. 循环结束后，输出完成。

{% include custom/custom-post-content-inner.html %}

---

### 示例代码

```cpp
#include <iostream>
using namespace std;
int main() {
    int n; // 定义整数变量n，用于存储矩阵的大小
    cin >> n; // 从输入流读取整数到n
    for (int i = 1; i <= n; i++) { // 从1到n进行循环，模拟每一行的输出
        cout << "|"; // 输出竖线，表示矩阵的边界
        for (int j = 1; j <= n - 2; j++) { // 从1到n-2进行循环，模拟每一行中间部分的输出
            if (i == 1 || i == n) { // 判断当前行是否是第一行或最后一行
                cout << "-"; // 如果是，则输出横线，形成矩阵的上下边界
            } else if (i == (n + 1) / 2) { // 判断当前行是否是中间行
                if (j == (n - 2 + 1) / 2) { // 判断当前列是否是中间列
                    cout << "x"; // 如果是，则输出小写字母x，形成矩阵的中间交叉点
                } else {
                    cout << "-"; // 否则，输出横线，形成矩阵的中间横线
                }
            } else { // 如果当前行不是第一行、最后一行或中间行
                if (j == (n - 2 + 1) / 2) { // 判断当前列是否是中间列
                    cout << "|"; // 如果是，则输出竖线，形成矩阵的中间竖线
                } else {
                    cout << "x"; // 否则，输出小写字母x，形成矩阵的内部
                }
            }
        }
        cout << "|" << endl; // 输出竖线，表示矩阵的边界，并换行
    }
    return 0;
}
```

---

{% include custom/custom-post-content-footer.md %}
